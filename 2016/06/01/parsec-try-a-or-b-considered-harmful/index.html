<!DOCTYPE html><html lang="en-us"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>Parsec: try a &lt;|&gt; b 有害论 | WHsT</title><meta name="description" content="用于回溯的 try 的作用域越小越好，一般把 try 放到对应 parser 的定义内。"><meta name="generator" content="WHsT"><meta name="author" content="Wang Hsü-Tung"><meta name="keywords" content="whst, Wang Hsutung, developer, C/C++, Linux, Vim, Haskell, Scheme"><meta name="HandheldFriendly" content="True"><meta name="MobileOptimized" content="320"><meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1,user-scalable=0"><link rel="stylesheet" type="text/css" href="/styles/screen.css"><link rel="apple-touch-icon" sizes="57x57" href="/images/apple-touch-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/images/apple-touch-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/images/apple-touch-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/images/apple-touch-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/images/apple-touch-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/images/apple-touch-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/images/apple-touch-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/images/apple-touch-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-180x180.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/images/favicon-96x96.png"><link rel="icon" type="image/png" sizes="160x160" href="/images/favicon-160x160.png"><link rel="icon" type="image/png" sizes="192x192" href="/images/favicon-192x192.png"><meta name="msapplication-TileColor" content="#121315"><meta name="msapplication-TileImage" content="/images/mstile-144x144.png"></head><body itemscope itemtype="https://schema.org/WebPage"><header itemscope itemtype="https://schema.org/WPHeader"><a href="/"><img src="/images/whst.png" alt="WHsT" title="WHsT"></a><h1><a href="/" alt="WHsT" title="WHsT" itemprop="headline">WHsT</a></h1><p itemprop="description">WHsT's name is <span itemprop='author' itemscope itemtype='https://schema.org/Person'>Wang Hsü-Tung</span>. <br>Twitter: <a href='https://twitter.com/xukiro' alt='@WANG Hsü-Tung on Twitter' title='@Wang Hsü-Tung'>@xukiro</a>, GitHub: <a href='https://github.com/whst' alt='@WANG Hsü-Tung on GitHub'>whst</a></p><nav itemscope itemtype="https://schema.org/SiteNavigationElement"><ul><li itemprop="name"><a href="/" alt="Home" title="Home" itemprop="url">Home</a></li><li itemprop="name"><a href="/articles" alt="Articles" title="Articles" itemprop="url">Articles</a></li><li itemprop="name"><a href="/inlog" alt="InLog" title="InLog" itemprop="url">InLog</a></li><li itemprop="name"><a href="/about" alt="About" title="About" itemprop="url">About</a></li></ul></nav><div class="space"></div></header><main itemscope itemtype="https://schema.org/Blog"><article class="full"><h1 itemprop="headline">Parsec: try a &lt;|&gt; b 有害论</h1><span class="post-meta">Published on<time itemprop="datePublished" datetime="2016-06-01T11:39:42.000Z"> 星期三, 六月 1日 2016 at 19:39</time><br>Last updated on<time itemprop="dateModified" datetime="2016-06-01T11:39:42.000Z"> 星期五, 六月 3日 2016 at 17:33</time></span><p>本文译自: <a href="http://blog.ezyang.com/2014/05/parsec-try-a-or-b-considered-harmful/" target="_blank" rel="external">http://blog.ezyang.com/2014/05/parsec-try-a-or-b-considered-harmful/</a></p>
<hr>
<blockquote>
<p>如果嫌长，请直接看结论：用于回溯的 try 的作用域越小越好，一般把 try 放到对应 parser 的定义内。</p>
</blockquote>
<p>你有没有用 Parsec 写过 parser, 但它对不合语法的代码报的错却语焉不详呢？<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"test.txt"</span> (line 15, column 7):</span><br><span class="line">unexpected <span class="string">'A'</span></span><br><span class="line">expecting end of input</span><br></pre></td></tr></table></figure></p>
<p>提示的错误位置看上去像是待编译代码中的任意行任意列，而且你确定错误应该源自一大堆 parser combinator 中的某一个。等一下！Parsec却不知怎么认为文件应当结尾。你四处寻找原因终于发现真正的错误实际上处于报告的位置的<em>后面</em>.</p>
<p>我们可能会想，“难怪 Parsec 在错误处理方面的这名声不咋地……”</p>
<hr>
<p>假设出现了这样的问题，而且要解析的也并非特别怪异的语法，那么产生这类不够详细的错误消息的原因一般是这样：程序员在代码中用很多用于回溯的 <code>try</code> 语句，正是回溯破坏了有用的错误状态。总之，在某个点 parser 若解析失败，它就想向用户报告错误原因，但是一个包围它的 <code>try</code> 语句会迫使 parser 回溯，然后尝试另一种解析方案（实际上没啥希望）。</p>
<p>现在用一个例子印证上面的观点：假设一个 Haskell 程序员用 parse combinator 为 Haskell 的模块导入写一个 parser:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">stmt</span> ::= <span class="keyword">import</span> <span class="keyword">qualified</span> A <span class="keyword">as</span> B</span><br><span class="line">       | <span class="keyword">import</span> A</span><br></pre></td></tr></table></figure></p>
<p>对 Parsec 内置的 <a href="http://hackage.haskell.org/package/parsec-3.0.0/docs/Text-Parsec-Token.html" target="_blank" rel="external">token combinators</a> 稍作了解，写出来的第一个版本可能像这样：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Text.Parsec</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">qualified</span> Text.Parsec.Token <span class="keyword">as</span> P</span><br><span class="line"><span class="keyword">import</span> Text.Parsec.Language (<span class="title">haskellDef</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Stmt</span> = <span class="type">QualifiedImport</span> <span class="type">String</span> <span class="type">String</span> | <span class="type">Import</span> <span class="type">String</span></span></span><br><span class="line">    <span class="keyword">deriving</span> (<span class="type">Show</span>)</span><br><span class="line"></span><br><span class="line"><span class="title">pStmt</span> = pQualifiedImport &lt;|&gt; pImport</span><br><span class="line"></span><br><span class="line"><span class="title">pQualifiedImport</span> = <span class="keyword">do</span></span><br><span class="line">    reserved <span class="string">"import"</span></span><br><span class="line">    reserved <span class="string">"qualified"</span></span><br><span class="line">    i &lt;- identifier</span><br><span class="line">    reserved <span class="string">"as"</span></span><br><span class="line">    i' &lt;- identifier</span><br><span class="line">    return (<span class="type">QualifiedImport</span> i i')</span><br><span class="line"></span><br><span class="line"><span class="title">pImport</span> = <span class="keyword">do</span></span><br><span class="line">    reserved <span class="string">"import"</span></span><br><span class="line">    i &lt;- identifier</span><br><span class="line">    return (<span class="type">Import</span> i)</span><br><span class="line"></span><br><span class="line"><span class="title">lexer</span> = <span class="type">P</span>.makeTokenParser (haskellDef</span><br><span class="line">    &#123; <span class="type">P</span>.reservedNames = <span class="type">P</span>.reservedNames haskellDef ++ [<span class="string">"qualified"</span>, <span class="string">"as"</span>] &#125;)</span><br><span class="line"><span class="title">identifier</span> = <span class="type">P</span>.identifier lexer</span><br><span class="line"><span class="title">reserved</span> = <span class="type">P</span>.reserved lexer</span><br><span class="line"></span><br><span class="line"><span class="title">parseStmt</span> input = parse (pStmt &gt;&gt; eof) <span class="string">"(unknown)"</span> input</span><br></pre></td></tr></table></figure></p>
<p>然而，这个 Parser 其实压根儿就解析不了常规的导入语句————它会产生这样的错误消息：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*Main&gt; parseStmt <span class="string">"import Foo"</span></span><br><span class="line">Left <span class="string">"(unknown)"</span> (line 1, column 8):</span><br><span class="line">unexpected <span class="string">"F"</span></span><br><span class="line">expecting <span class="string">"qualified"</span></span><br></pre></td></tr></table></figure></p>
<p>稍微谷歌一下，可以知道 <a href="http://stackoverflow.com/questions/9976388/haskell-text-parsec-combinator-choice-doesnt-backtrack" target="_blank" rel="external">Parsec 默认不回溯</a>。嗯，这不算什么大问题，为啥不往 parser 里面加一个 try 语句呢：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">pStmt</span> = try pQualifiedImport &lt;|&gt; pImport</span><br></pre></td></tr></table></figure></p>
<p>这样就能让两个 Parser 都正常运行了。而且从这里，我们为以后用 Parsec 写 parser 得出了一些“经验”：</p>
<blockquote>
<p>如果要在多个 parser 分支之间作出选择，但是有的 parser 会消耗输入。那么，在每个分支 parser 前面插一个 <code>try</code> 就 OK, 因为这样能回溯。</p>
</blockquote>
<p>不知不觉中，Parsec 的用户就引入了不好的报错方式：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*Main&gt; parseStmt <span class="string">"import qualified Foo s B"</span></span><br><span class="line">Left <span class="string">"(unknown)"</span> (line 1, column 17):</span><br><span class="line">unexpected reserved word <span class="string">"qualified"</span></span><br><span class="line">expecting letter or digit or <span class="string">"#</span></span><br></pre></td></tr></table></figure></p>
<p>呃，等下……上面这个例子中我们希望它提示“有一个未预期的标识符 s”, 因为我们希望得到 <code>as</code>. 但是发现这个错误的时候，Parsec 没有报告出来，而是回溯了，它尝试用 <code>pImport</code> 的规则来匹配，然后再次失败。但这个时候，另一个分支的错误原因却已经永远丢失，不能再显示……</p>
<p>要咋修复这个问题呢？此问题在于，有时候我们程序员知道回溯已经没用了，但是这段代码还是会傻傻地回溯。在这个例子里，一旦解析出了 <code>import qualified</code>, 我们就已经知道这是个 qualified import 语句，就不应该再回溯。那么怎么让 Parsec 理解这个规则？很简单，减少 try 回溯操作的作用域:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">pStmt</span> = pQualifiedImport &lt;|&gt; pImport</span><br><span class="line"></span><br><span class="line"><span class="title">pQualifiedImport</span> = <span class="keyword">do</span></span><br><span class="line">    try $ <span class="keyword">do</span></span><br><span class="line">        reserved <span class="string">"import"</span></span><br><span class="line">        reserved <span class="string">"qualified"</span></span><br><span class="line">    i &lt;- identifier</span><br><span class="line">    reserved <span class="string">"as"</span></span><br><span class="line">    i' &lt;- identifier</span><br><span class="line">    return (<span class="type">QualifiedImport</span> i i')</span><br></pre></td></tr></table></figure></p>
<p>这里，我把 <code>try</code> 从 <code>pStmt</code> 当中移到了 <code>pQualifiedImport</code> 当中，所以这次只会在读取 <code>import qualified</code> 失败的时候回溯。一旦它读取到了，我们就消耗了这些 token, 并且确定了这是个 qualified import. 这个版本的错误信息就好看些了：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*Main&gt; parseStmt <span class="string">"import qualified Foo s F"</span></span><br><span class="line">Left <span class="string">"(unknown)"</span> (line 1, column 22):</span><br><span class="line">unexpected <span class="string">"s"</span></span><br><span class="line">expecting <span class="string">"as"</span></span><br></pre></td></tr></table></figure></p>
<p>此例要说明的意思在于：用于回溯的 try 的作用域越小越好，一般把 try 放到对应 parser 的定义内。这样就需要用点人类的智慧：你得确定需要多少预读符号（lookahead）才能决定进入一个分支，这通常取决于 Parser <em>怎么</em>用。还好，大多数语言设计的时候就考虑了这点，因此它们要预读的符号不算太多。而且对于那些我想用 Parsec 的项目，我愿意为此牺牲一点模块性。</p>
<hr>
<p>如果从另一个角度看这个问题，其实这锅应该由 Parsec 来背：它根本就不该提供一个这样能把错误消息搞得乱七八糟的 API —— 为何不能自动判断要预读的符号呢？尽管传统的 Parser 生成器能够做到这些（而且在我们先前的例子里还能通过避免回溯来提高效率），其实是因为有一些基本的原因决定了 Parsec combinator（以及与之类似的 Monadic parser combinator）不能<a href="http://stackoverflow.com/a/7863380/23845" target="_blank" rel="external">判断预判符号是什么</a>。这就是很多 Haskell 程序员更倾向于使用高效但却<a href="https://hackage.haskell.org/package/attoparsec" target="_blank" rel="external">无错误处理的 parser</a> 的原因。</p>
<p>那么为什么要写这篇文章呢？因为还是有不少文献推荐用 Parsec, 而且 Haskell 初学应该不会用 Parsec 实现他们的第一个 parser。最后，如果你想用 Parsec 写一个 parser, 那么你最好还是花点时间来限制回溯————这样你用 Parsec 的时候可能要<em>顺手得多</em>。</p>
</article><section id="comments"><!--多说评论框--><div data-thread-key="post-parsec-try-a-or-b-considered-harmful" data-title="Parsec: try a &lt;|&gt; b 有害论" data.url="http://whst.github.io/2016/06/01/parsec-try-a-or-b-considered-harmful/" class="ds-thread"></div><div id="ds_thread"></div><!--多说评论框 END--><script type="text/javascript"> var duoshuoQuery = {short_name: 'http://whst.duoshuo.com/'};
 (function() {
     var ds = document.createElement('script');
     ds.type = 'text/javascript';ds.async = true;
     ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
     ds.charset = 'UTF-8';
     (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds);
 })();</script><noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus</a>.</noscript></section></main></body></html>