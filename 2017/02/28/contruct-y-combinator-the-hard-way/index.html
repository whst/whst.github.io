<!DOCTYPE html><html lang="en-us"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>笨方法构造 Y-combinator | WHsT</title><meta name="description"><meta name="generator" content="WHsT"><meta name="author" content="Wang Hsü-Tung"><meta name="keywords" content="whst, Wang Hsutung, developer, C/C++, Linux, Vim, Haskell, Scheme"><meta name="HandheldFriendly" content="True"><meta name="MobileOptimized" content="320"><meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1,user-scalable=0"><link rel="stylesheet" type="text/css" href="/styles/screen.css"><link rel="apple-touch-icon" sizes="57x57" href="/images/apple-touch-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/images/apple-touch-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/images/apple-touch-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/images/apple-touch-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/images/apple-touch-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/images/apple-touch-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/images/apple-touch-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/images/apple-touch-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-180x180.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/images/favicon-96x96.png"><link rel="icon" type="image/png" sizes="160x160" href="/images/favicon-160x160.png"><link rel="icon" type="image/png" sizes="192x192" href="/images/favicon-192x192.png"><meta name="msapplication-TileColor" content="#121315"><meta name="msapplication-TileImage" content="/images/mstile-144x144.png"></head><body itemscope itemtype="https://schema.org/WebPage"><header itemscope itemtype="https://schema.org/WPHeader"><a href="/"><img src="/images/whst.png" alt="WHsT" title="WHsT"></a><h1><a href="/" alt="WHsT" title="WHsT" itemprop="headline">WHsT</a></h1><p itemprop="description">WHsT's name is <span itemprop='author' itemscope itemtype='https://schema.org/Person'>Wang Hsü-Tung</span>. <br>Twitter: <a href='https://twitter.com/xukiro' alt='@WANG Hsü-Tung on Twitter' title='@Wang Hsü-Tung'>@xukiro</a>, GitHub: <a href='https://github.com/whst' alt='@WANG Hsü-Tung on GitHub'>whst</a></p><nav itemscope itemtype="https://schema.org/SiteNavigationElement"><ul><li itemprop="name"><a href="/" alt="Home" title="Home" itemprop="url">Home</a></li><li itemprop="name"><a href="/articles" alt="Articles" title="Articles" itemprop="url">Articles</a></li><li itemprop="name"><a href="/inlog" alt="InLog" title="InLog" itemprop="url">InLog</a></li><li itemprop="name"><a href="/about" alt="About" title="About" itemprop="url">About</a></li></ul></nav><div class="space"></div></header><main itemscope itemtype="https://schema.org/Blog"><article class="full"><h1 itemprop="headline">笨方法构造 Y-combinator</h1><span class="post-meta">Published on<time itemprop="datePublished" datetime="2017-02-28T07:24:06.000Z"> 星期二, 二月 28日 2017 at 15:24</time><br>Last updated on<time itemprop="dateModified" datetime="2017-02-28T07:24:06.000Z"> 星期二, 二月 28日 2017 at 15:41</time></span><hr>
<p>最近 Y-combinator （也叫不动点组合子）这个名词挺火的，一方面因为美国有个孵化器取了这个名字，另一方面则是因为「函数式编程」一定程度上的普及。部分「大V」在微博上故弄玄虚，甚至看到有人说「等你会写 yc 了再和我争论这个问题」，先不说把 Y-combinator 缩写成 yc 像是把 HTML5 缩写成 H5 那样好笑，这种态度像是 Y-combinator 是什么了不起的东西，让人哭笑不得。</p>
<p>这里就对这个东西科普一下，消除没有接触过的人对它的神秘感。本文假设读者会 Lisp 或 Python 中的一种语言，不需要额外的数学基础。</p>
<p>从概念上说，不动点其实很简单，函数 f 的不动点是一个值 x 使得 f(x) = x. 而高阶函数的不动点则是一个函数，即 y f = f (y f)。</p>
<p>MIT-Scheme 的 logo 上面的 (Y F) = (F (Y F)) 以及无穷递归的图案，实际上就代表这个意思:<br><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/a/a2/MIT_GNU_Scheme_Logo.svg/220px-MIT_GNU_Scheme_Logo.svg.png" alt="MIT-Scheme"></p>
<p>下面我们通过一个最简单的问题开始，循序渐进地推导Y组合子。以下示例代码基于《The Little Schemer》第九章改写。</p>
<p>首先，如果我们用普通的递归函数计算一个链表的长度，它应该是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(define length</span><br><span class="line">  (lambda (l)</span><br><span class="line">    (if (null? l)</span><br><span class="line">      0</span><br><span class="line">      (+ 1 (length (cdr l))))))</span><br></pre></td></tr></table></figure></p>
<p>如果不懂 Scheme 也没关系，它大致等价于这段 Python 代码（注意对空表取反会得到 True）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">length = lambda l: 0 if not l else 1 + lenth(l[1:])</span><br></pre></td></tr></table></figure></p>
<p>这是最正常、最容易想到的写法。然而数学里最原始的 <a href="https://zh.wikipedia.org/wiki/%CE%9B%E6%BC%94%E7%AE%97" target="_blank" rel="external">λ演算</a> 中，所有函数都是匿名的。<br>也就是说，不能像最上面的这段代码一样给函数用 define 绑定一个名字，然后在函数体内调用这个函数自己。那么λ演算如何实现递归？</p>
<p>不如先假设有一个函数 ERROR，它接受一个参数，然后马上报错。<br>由于函数定义是匿名的，我们无法在函数内再通某个名字调用自身了。所以暂时用 ERROR 函数替代原来的 length：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(lambda (l)</span><br><span class="line">  (if (null? l)</span><br><span class="line">    0</span><br><span class="line">    (+ 1 (ERROR (cdr l)))))</span><br></pre></td></tr></table></figure></p>
<p>这个函数可以处理空表，但是一旦表长度超过 0，就会调用 ERROR 产生错误。</p>
<p>那能否把函数体自己替换 ERROR 函数呢？这样就能调用「自己」了。像下面这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(lambda (l)</span><br><span class="line">  (if (null? l)</span><br><span class="line">    0</span><br><span class="line">    (+ 1 ((lambda (l)</span><br><span class="line">            (if (null? l)</span><br><span class="line">              0</span><br><span class="line">              (+ 1 (ERROR (cdr l)))))</span><br><span class="line">          (cdr l)))))</span><br></pre></td></tr></table></figure></p>
<p>这下可以处理空表和长度为 1 的表。但是显然它还不够，因为如果列表长度超过 1 ，还是会触发 ERROR。<br>我们可以（无脑地）继续展开括号处：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(lambda (l)</span><br><span class="line">  (if (null? l)</span><br><span class="line">    0</span><br><span class="line">    (+ 1 ((lambda (l)</span><br><span class="line">            (if (null? l)</span><br><span class="line">              0</span><br><span class="line">              (+ 1 ((lambda (l)</span><br><span class="line">                     (if (null? l)</span><br><span class="line">                       0</span><br><span class="line">                       (+ 1 (ERROR (cdr l)))))</span><br><span class="line">                    (cdr l)))))</span><br><span class="line">          (cdr l)))))</span><br></pre></td></tr></table></figure></p>
<p>这个函数可以处理列表长度不超过 2 的情况。</p>
<p>作为强迫症，这层层嵌套的匿名函数实在是太难看了，我们可以把函数在 if 在 else 分支要调用什么函数拿出来，作为一个单独的参数 func，这样可以让代码看起来平整一点：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">((lambda (func)</span><br><span class="line">   (lambda (l)</span><br><span class="line">     (if (null? l)</span><br><span class="line">       0</span><br><span class="line">       (+ 1 (func (cdr l))))))</span><br><span class="line"> ((lambda (func)</span><br><span class="line">    (lambda (l)</span><br><span class="line">      (if (null? l)</span><br><span class="line">        0</span><br><span class="line">        (+ 1 (func (cdr l))))))</span><br><span class="line">  ((lambda (func)</span><br><span class="line">     (lambda (l)</span><br><span class="line">       (if (null? l)</span><br><span class="line">         0</span><br><span class="line">         (+ 1 (func (cdr l))))))</span><br><span class="line">   ERROR)))</span><br></pre></td></tr></table></figure></p>
<p>这段代码和上一段本质相同，但好看些。然而，完全重复的代码还是很多。<br>观察其中的模式：每个函数取有一个形参 func，在表不为空时候调用 func 函数，而 func 绑定的实参和函数自己一模一样。所以可以继续把这个过程抽象一下，把重复的代码抽出来传给另一个函数，而另一个函数则负责重复这个模式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">((lambda (mk-length)</span><br><span class="line">   (mk-length (mk-length (mk-length ERROR))))</span><br><span class="line"> (lambda (func)</span><br><span class="line">   (lambda (l)</span><br><span class="line">     (if (null? l)</span><br><span class="line">       0</span><br><span class="line">       (+ 1 (func (cdr l)))))))</span><br></pre></td></tr></table></figure></p>
<p>这下好看多了~<br>不过我们一开始的问题还是没解决：如果表长度超过了 2，这里还是会调用 ERROR。</p>
<p>如果观察能力敏锐的话，你也许已经看出来了……<br>是的，为什么非得死心眼地把 ERROR 传给 mk-length 呢？完全可以把 mk-length 传给他自己啊！这样就能让下面这个匿名函数不断地调用自己了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">((lambda (mk-length)</span><br><span class="line">   (mk-length mk-length))</span><br><span class="line"> (lambda (func)</span><br><span class="line">   (lambda (l)</span><br><span class="line">     (if (null? l)</span><br><span class="line">       0</span><br><span class="line">       (+ 1 (func (cdr l)))))))</span><br></pre></td></tr></table></figure></p>
<p>先别高兴，这段代码实际上有错！！！如果你扔给它一个列表，解释器会告诉你「不能把 procedure 和 number 相加」。不难看出来，是因为最后一行的 func 实际上不能直接应用到列表上，而需要先给他一个函数，这样才能返回一个接受列表的函数。这很好处理，把 <code>func</code> 改成 <code>(func func)</code> 即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">((lambda (mk-length)</span><br><span class="line">     (mk-length mk-length))</span><br><span class="line">   (lambda (func)</span><br><span class="line">     (lambda (l)</span><br><span class="line">       (if (null? l)</span><br><span class="line">         0</span><br><span class="line">         (+ 1 ((func func) (cdr l)))))))</span><br></pre></td></tr></table></figure></p>
<p>函数参数的名字并不重要，不如统一成同样的名字：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">((lambda (mk-length)</span><br><span class="line">     (mk-length mk-length))</span><br><span class="line">   (lambda (mk-length)</span><br><span class="line">     (lambda (l)</span><br><span class="line">       (if (null? l)</span><br><span class="line">         0</span><br><span class="line">         (+ 1 ((mk-length mk-length) (cdr l)))))))</span><br></pre></td></tr></table></figure></p>
<p>等价 Python 代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(lambda mkLength: mkLength(mkLength))\</span><br><span class="line">    (lambda mkLength: lambda l:\</span><br><span class="line">        0 if not l else 1 + mkLength(mkLength)(l[1:]))</span><br></pre></td></tr></table></figure></p>
<p>你可以亲手在解释器里试试，现在这个函数可以工作了。<br>现在的问题是，这个函数已经被我们改得面目全非，尤其是这个 <code>(mk-length mk-length)</code> 一点也不像原来的 length 函数。我们不如弄一个参数叫 length，然后传 <code>(mk-length mk-length)</code> 给他：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">((lambda (mk-length)</span><br><span class="line">     (mk-length mk-length))</span><br><span class="line">   (lambda (mk-length)</span><br><span class="line">     ((lambda (length)</span><br><span class="line">        (lambda (l)</span><br><span class="line">       (if (null? l)</span><br><span class="line">         0</span><br><span class="line">         (+ 1 (length (cdr l))))))</span><br><span class="line">      (mk-length mk-length))))</span><br></pre></td></tr></table></figure></p>
<p>这下和原始的 length 函数有点像了，不幸的是它会陷入无限递归。因为在上一个正确版本中，<code>(mk-length mk-length)</code>只在表非空时需要被求值；而这一个版本会在 if 执行前先对它求值，导致无穷尽的展开。这里我们的 trick 是创建一个新的等价匿名函数：用 <code>(lambda (x) ((mk-length mk-length) x)</code> 代替 <code>(mk-length mk-length)</code>。如此一来，只会在调用这个匿名函数的时候对 <code>(mk-length mk-length)</code> 求值。这次修改后函数长这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">((lambda (mk-length)</span><br><span class="line">     (mk-length mk-length))</span><br><span class="line">   (lambda (mk-length)</span><br><span class="line">     ((lambda (length)</span><br><span class="line">        (lambda (l)</span><br><span class="line">       (if (null? l)</span><br><span class="line">         0</span><br><span class="line">         (+ 1 (length (cdr l))))))</span><br><span class="line">      (lambda (x) ((mk-length mk-length) x)))))</span><br></pre></td></tr></table></figure></p>
<p>现在可以看到，上面这段代码的第 4 ~ 8 行已经和最开始的代码几乎相同一样了。 我们把他移出来放到末尾的 6 ~ 10 行（虚线是为了方便观察画的）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">((lambda (le)</span><br><span class="line"> ((lambda (mk-length)</span><br><span class="line">     (mk-length mk-length))</span><br><span class="line">   (lambda (mk-length)</span><br><span class="line">     (le (lambda (x) ((mk-length mk-length) x))))))</span><br><span class="line"> - - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line"> (lambda (length)</span><br><span class="line">        (lambda (l)</span><br><span class="line">       (if (null? l)</span><br><span class="line">         0</span><br><span class="line">         (+ 1 (length (cdr l)))))))</span><br></pre></td></tr></table></figure></p>
<p>现在你可以看到，虚线下面几乎和原函数相同。而虚线上面这个函数，实际上就是 Y-combinator！因此 Y-combinator 用代码是这样定义的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(define Y</span><br><span class="line">  (lambda (le)</span><br><span class="line">    ((lambda (f) (f f))</span><br><span class="line">     (lambda (f)</span><br><span class="line">       (le (lambda (x) ((f f) x)))))))</span><br></pre></td></tr></table></figure></p>
<p>Python 版：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Y = lambda le: (lambda f: f(f)) (lambda f: le(lambda x: f(f)(x)))</span><br></pre></td></tr></table></figure></p>
<p>接下来就可以测试一番了 ^_^</p>
<p><img src="http://wx1.sinaimg.cn/large/89eced40gy1fd67jzk0ifj20f70gj0u4.jpg" alt="Scheme 测试"><br><img src="http://wx2.sinaimg.cn/large/89eced40gy1fd67jxu37zj20nt0g9405.jpg" alt="Python 测试"></p>
<p>这就是 applicative order Y-combinator，用他就能实现匿名函数的递归调用啦 :-P</p>
<hr>
<p>另外说几句。在 Haskell 这样的惰性求值的语言中，写Y不动点组合子更简单。我们只需要完全按定义来：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">fix</span> :: (a -&gt; a) -&gt; a</span><br><span class="line"><span class="title">fix</span> f = f (fix f)</span><br></pre></td></tr></table></figure></p>
<p>再有函数类似于<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f = \length l -&gt; if null l then 0 else succ . length $ tail l</span><br></pre></td></tr></table></figure></p>
<p>然后可以输入表达式 <code>(fix f) [1..n]</code> 就可以得到长度 n. 很方便吧~</p>
</article><section id="comments"><!--多说评论框--><div data-thread-key="post-contruct-y-combinator-the-hard-way" data-title="笨方法构造 Y-combinator" data.url="http://whst.github.io/2017/02/28/contruct-y-combinator-the-hard-way/" class="ds-thread"></div><div id="ds_thread"></div><!--多说评论框 END--><script type="text/javascript"> var duoshuoQuery = {short_name: 'whst'};
 (function() {
     var ds = document.createElement('script');
     ds.type = 'text/javascript';ds.async = true;
     ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
     ds.charset = 'UTF-8';
     (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds);
 })();</script><noscript>Please enable JavaScript to view the comments.</noscript></section></main></body></html>